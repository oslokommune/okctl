package helm_test

import (
	"context"
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"path"
	"testing"
	"time"

	"github.com/oslokommune/okctl/pkg/config"
	"github.com/oslokommune/okctl/pkg/helm"
	"github.com/sanity-io/litter"
	"github.com/spf13/afero"
	"github.com/stretchr/testify/assert"

	k3dCluster "github.com/rancher/k3d/v3/pkg/cluster"
	"github.com/rancher/k3d/v3/pkg/runtimes"
	k3d "github.com/rancher/k3d/v3/pkg/types"
)

func createCluster(kubeConfPath string) func() {
	ctx := context.Background()

	createClusterOpts := &k3d.ClusterCreateOpts{
		DisableImageVolume:  false,           // Default
		WaitForServer:       true,            // Default
		Timeout:             1 * time.Minute, // Default is 0 * time.second, but says must be more than 1
		DisableLoadBalancer: false,           // Default
		K3sServerArgs:       nil,             // Default
		K3sAgentArgs:        nil,             // Default
	}

	serverNode := &k3d.Node{
		Name:    "",
		Role:    k3d.ServerRole,
		Image:   "rancher/k3s:latest",
		Volumes: nil,
		Env:     nil,
		Cmd:     nil,
		Args:    createClusterOpts.K3sServerArgs,
		Ports:   nil,
		Restart: false,
		Labels:  nil,
		Network: "",
		ServerOpts: k3d.ServerOpts{
			IsInit:    true,
			ExposeAPI: k3d.ExposeAPI{},
		},
	}

	cluster := &k3d.Cluster{
		Name: "test-cluster",
		Network: k3d.ClusterNetwork{
			Name:     "host", // Enables host network
			External: true,
		},
		Token: "", // Generated by default
		Nodes: []*k3d.Node{
			serverNode,
		},
		InitNode:          serverNode,
		ExternalDatastore: k3d.ExternalDatastore{},
		CreateClusterOpts: createClusterOpts,
		ExposeAPI: k3d.ExposeAPI{
			Host:   k3d.DefaultAPIHost,
			HostIP: k3d.DefaultAPIHost,
			Port:   k3d.DefaultAPIPort,
		},
		ServerLoadBalancer: nil,
		ImageVolume:        "",
	}

	if err := k3dCluster.ClusterCreate(ctx, runtimes.SelectedRuntime, cluster); err != nil {
		// rollback if creation failed
		fmt.Printf("failed to create cluster: %s\n", err)
		if err := k3dCluster.ClusterDelete(ctx, runtimes.SelectedRuntime, cluster); err != nil {
			log.Fatalf("failed to rollback cluster: %s\n", err)
		}
		log.Fatalln("Cluster creation FAILED, all changes have been rolled back!")
	}
	log.Printf("Cluster '%s' created successfully!\n", cluster.Name)

	_, err := k3dCluster.KubeconfigGetWrite(
		ctx,
		runtimes.SelectedRuntime,
		cluster,
		kubeConfPath,
		&k3dCluster.WriteKubeConfigOptions{
			UpdateExisting:       true,
			OverwriteExisting:    true,
			UpdateCurrentContext: true,
		},
	)
	if err != nil {
		log.Fatalf("failed to write kubecnofig: %s", err)
	}

	return func() {
		if err := k3dCluster.ClusterDelete(ctx, runtimes.SelectedRuntime, cluster); err != nil {
			log.Fatalf("failed to cleanup cluster: %s\n", err)
		}
	}
}

func TestEstablishEnv(t *testing.T) {
	testCases := []struct {
		name   string
		envs   map[string]string
		expect []string
	}{
		{
			name: "Should work",
			envs: map[string]string{
				"SOMETHING": "cool",
			},
			expect: []string{
				"SOMETHING=cool",
			},
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			before := os.Environ()

			restoreFn, err := helm.EstablishEnv(tc.envs)
			assert.NoError(t, err)
			assert.Equal(t, tc.expect, os.Environ())

			err = restoreFn()
			assert.NoError(t, err)
			assert.Equal(t, before, os.Environ())
		})
	}
}

func TestHelm(t *testing.T) {
	dir, err := ioutil.TempDir("", "testHelm")
	assert.NoError(t, err)
	defer func() {
		_ = os.RemoveAll(dir)
	}()

	log.Printf("config directory: %s\n", dir)

	deleteClusterFn := createCluster(path.Join(dir, config.DefaultClusterKubeConfig))
	defer deleteClusterFn()

	testCases := []struct {
		name      string
		helm      *helm.Helm
		expect    interface{}
		expectErr bool
	}{
		{
			name: "Should work",
			helm: helm.New(&helm.Config{
				Namespace:            "test-helm",
				KubeConfig:           path.Join(dir, config.DefaultClusterKubeConfig),
				HelmPluginsDirectory: path.Join(dir, config.DefaultHelmBaseDir, config.DefaultHelmPluginsDirectory),
				HelmRegistryConfig:   path.Join(dir, config.DefaultHelmBaseDir, config.DefaultHelmRegistryConfig),
				HelmRepositoryConfig: path.Join(dir, config.DefaultHelmBaseDir, config.DefaultHelmRepositoryConfig),
				HelmRepositoryCache:  path.Join(dir, config.DefaultHelmBaseDir, config.DefaultHelmRepositoryCache),
				HelmBaseDir:          path.Join(dir, config.DefaultHelmBaseDir),
				Debug:                true,
			}, &afero.Afero{
				Fs: afero.NewOsFs(),
			}),
		},
	}

	for _, tc := range testCases {
		tc := tc

		err := tc.helm.RepoAdd("stable", "https://kubernetes-charts.storage.googleapis.com")
		assert.NoError(t, err)

		err = tc.helm.RepoUpdate()
		assert.NoError(t, err)

		release, err := tc.helm.Install("mysql-dev", "stable", "mysql", map[string]string{
			"set": "mysqlRootPassword=admin@123,persistence.enabled=false,imagePullPolicy=Always",
		})
		assert.NoError(t, err)
		log.Println(litter.Sdump(release))

		if tc.expectErr {
		} else {
		}
	}
}
