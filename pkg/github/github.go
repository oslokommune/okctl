// Package github provides a client for interacting with the Github API
package github

import (
	"context"
	"fmt"

	"github.com/google/go-github/v32/github"
	githubAuth "github.com/oslokommune/okctl/pkg/credentials/github"
	"golang.org/x/oauth2"
)

// DefaultOrg is the default organisation used with okctl
const DefaultOrg = "oslokommune"

// DefaultAWSInfrastructureRepository is the name of the infrastructure as code repository which should be given
// nameserver delegation requests
const DefaultAWSInfrastructureRepository = "origo-aws-infrastructure"

// DefaultAWSInfrastructurePrimaryBranch is the name of the primary branch (due to git/github moving away from "master"
// to "main")
const DefaultAWSInfrastructurePrimaryBranch = "master"

// Githuber invokes the github API
type Githuber interface {
	Teams(org string) ([]*Team, error)
	Repositories(org string) ([]*Repository, error)
	CreateDeployKey(org, repository, title, publicKey string) (*Key, error)
	DeleteDeployKey(org, repository string, id int64) error
	CreateNSRecordPullRequest(sourceBranch string) error
	HasExistingNSRecordPullRequest(potentialBranch string) (bool, error)
}

// Github contains the state for interacting with the github API
type Github struct {
	Ctx    context.Context
	Client *github.Client
}

// Ensure that Github implements Githuber
var _ Githuber = &Github{}

// Repository shadows github.Repository
type Repository = github.Repository

// Team shadows github.Team
type Team = github.Team

// Key shadows github.Key
type Key = github.Key

// New returns an initialised github API client
func New(ctx context.Context, auth githubAuth.Authenticator) (*Github, error) {
	credentials, err := auth.Raw()
	if err != nil {
		return nil, fmt.Errorf("failed to get github credentials: %w", err)
	}

	client := github.NewClient(
		oauth2.NewClient(ctx,
			oauth2.StaticTokenSource(
				&oauth2.Token{
					AccessToken: credentials.AccessToken,
				},
			),
		),
	)

	return &Github{
		Ctx:    ctx,
		Client: client,
	}, nil
}

// Teams fetches all teams within the given organisation
func (g *Github) Teams(org string) ([]*Team, error) {
	opts := &github.ListOptions{
		PerPage: 10, // nolint: gomnd
	}

	var allTeams []*github.Team

	for {
		teams, resp, err := g.Client.Teams.ListTeams(g.Ctx, org, opts)
		if err != nil {
			return nil, fmt.Errorf("failed to retrieve teams: %w", err)
		}

		allTeams = append(allTeams, teams...)

		if resp.NextPage == 0 {
			break
		}

		opts.Page = resp.NextPage
	}

	return allTeams, nil
}

// Repositories fetches all the repositories within the given organisation
func (g *Github) Repositories(org string) ([]*Repository, error) {
	opts := &github.RepositoryListByOrgOptions{
		ListOptions: github.ListOptions{
			PerPage: 10, // nolint: gomnd
		},
	}

	var allRepos []*github.Repository

	for {
		repos, resp, err := g.Client.Repositories.ListByOrg(g.Ctx, org, opts)
		if err != nil {
			return nil, fmt.Errorf("failed to retrieve repositories: %w", err)
		}

		allRepos = append(allRepos, repos...)

		if resp.NextPage == 0 {
			break
		}

		opts.Page = resp.NextPage
	}

	return allRepos, nil
}

// CreateDeployKey creates a read-only deploy key for the given owner/repo
func (g *Github) CreateDeployKey(org, repository, title, publicKey string) (*Key, error) {
	key, _, err := g.Client.Repositories.CreateKey(g.Ctx, org, repository, &github.Key{
		Title:    &title,
		Key:      &publicKey,
		ReadOnly: BoolPtr(true),
	})
	if err != nil {
		return nil, fmt.Errorf("creating deploy key: %w", err)
	}

	return key, nil
}

// DeleteDeployKey removes a read-only deploy key
func (g *Github) DeleteDeployKey(org, repository string, identifier int64) error {
	_, err := g.Client.Repositories.DeleteKey(g.Ctx, org, repository, identifier)
	if err != nil {
		return fmt.Errorf("deleting deploy key: %w", err)
	}

	return nil
}

// CreateNSRecordPullRequest creates a pull request from sourceBranch to destinationBranch
func (g *Github) CreateNSRecordPullRequest(sourceBranch string) (err error) {
	_, _, err = g.Client.PullRequests.Create(g.Ctx, DefaultOrg, DefaultAWSInfrastructureRepository, &github.NewPullRequest{
		Title: StringPtr(fmt.Sprintf("ðŸ“® Hosted Zone delegation request for %s", sourceBranch)),
		Head:  StringPtr(sourceBranch),
		Base:  StringPtr(DefaultAWSInfrastructurePrimaryBranch),
		Body:  StringPtr("Autogenerated by okctl"),
	})
	if err != nil {
		return fmt.Errorf("error creating pull request: %w", err)
	}

	return nil
}

// HasExistingNSRecordPullRequest checks the top level IAC repo to see if theres an incoming PR for a NS record
func (g *Github) HasExistingNSRecordPullRequest(potentialBranch string) (bool, error) {
	pullRequests, _, err := g.Client.PullRequests.List(g.Ctx, DefaultOrg, DefaultAWSInfrastructureRepository, &github.PullRequestListOptions{})
	if err != nil {
		return false, fmt.Errorf("error listing pull requests: %w", err)
	}

	for _, pr := range pullRequests {
		if *pr.Head.Ref == potentialBranch {
			return true, nil
		}
	}

	return false, nil
}

// BoolPtr returns a pointer to the bool
func BoolPtr(v bool) *bool {
	return &v
}

// StringPtr returns a pointer to the string
func StringPtr(v string) *string {
	return &v
}

// Int64Ptr returns a pointer to the int64
func Int64Ptr(v int64) *int64 {
	return &v
}
